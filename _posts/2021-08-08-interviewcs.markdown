---
layout: post
title:  "Interview CS 정리"
date:   2021-08-08 10:45:14 +0900
categories: ETC
---
면접에서 중요한 것은 면접관의 질문이 구체적으로 들어오지 않기 때문에 횡설수설 하지 않고 핵심을 대답해야 한다는 것이다. 그러므로 항상 면접관의 의도를 파악하고 핵심을 말하는 연습이 되어 있어야 한다. 구체적인 내용은 추가로 면접관이 물어보는 경우가 많다. 따라서 쉐도우 복싱으로 어떠한 질문이 들어 왔을때 어떻게 간결하게 답변을 하고 만약 핵심키워드가 등장하지 않는다면 이어지는 질문으로 구체적으로 물어보기도 한다.

## 자료구조
- Array
- Linked List
- Stack
- Queue
- Hash Table
- Tree
- Heap


#### Hash Table
Q1. HashTable은 무엇인가요?
해시 테이블은 Key, Value쌍으로 데이터를 저장하는데 삽입 삭제 검색이 모두 평균적으로 선형시간 내에 이루어지는 자료구조입니다.

Q2. 삽입삭제검색이 선형시간내에 이루어질 수 있는 이유는 무엇인가요?
해시테이블은 내부적으로 버킷이라고 불리는 배열에 키와 값을 저장하는데요, 해시함수를 통해 key의 해시 값을 생성하고 그 해시값을 통해 index를 결정하기 때문에 key에 따라 저장될 위치가 결정 되기 때문에 배열 전체를 탐색하지 않아도 되기 떄문에 빠릅니다.

Q3. index가 같아진다면 어떻게 하나요?
이 상황을 해시 충돌이라고 표현하는데요, 이 해시충돌을 해결하는 방법으로 여러가지가 있습니다. 크게 두가지로 나눌 수 있습니다. Open Adderss 방법 separate chaining 즉 개방주소법 분리연결법 두가지로 나뉜다. 개방주소법은 저장해야할 버킷에 이미 다른 값이 저장되어 있다면 다른 버킷에 저장하는 방법이고 분리 연결법은 이 버킷을 각각 링크드리스트나 트리로 구성하는 것입니다.

#### Array
Q1. Array는 무엇인가요?
Array는 같은 타입의 데이터를 순차적으로 저장하는 선형 자료구조 입니다. 연속적으로 데이터들이 저장되어 index로 원소에 접근 할 수 있습니다.

Q2. Array의 시간복잡도는 어떻게 되나요?
접근 시간복잡도는 O(1), 삽입, 삭제에 대한 복잡도는 O(N)이다

#### Linked List
Q1. Linked List는 무엇인가요?
LinkedList는 데이터와 포인터로 구성된 Node가 연결된 선형 자료구조입니다. 배열과 달리 연속적인 메모리에 저장되지 않아 Index로 접근 할 수 없고 Node안에 포인터로 접근할 수 있습니다.

class Node<T> {
    var value: T
    var next: Node<T>?
}
Q2. Linked List의 시간복잡도는 어떻게 되나요?
접근 시간복잡도는 O(N)이고, 삽입 삭제에 대한 복잡도는 O(1)이지만 삭제나 삽입할 위치로 이동하는데 O(N)의 시간복잡도를 가져 엄밀히 말하자면 O(N)이지만 연속되는 위치에서 삽입과 삭제가 이루어진다면 O(1)의 시간복잡도를 갖습니다..
Swift에서는 직접적으로 LinkedList를 제공하고 있지 않습니다.

#### Stack, Queue
Q1. Stack은 무엇인가요?
스택은 원소의 삽입 삭제가 Top에서만 이루어지는 선형 자료구조 입니다. 한곳에서만 삽입 삭제가 가능하기 때문에 last in first out (LIFO)방식으로 가장 마지막에 삽입된 원소가 가장 먼저 삭제되는 특징이 있습니다.

Q2. Queue는 무엇인가요?
큐는 한쪽에서는 원소의 삽입만, 다른한쪽에서는 원소의 삭제만 가능한 선형 자료구조 입니다. First in First out으로 가장 먼저 삽입된 원소가 가장먼저 삭제되는 특징을 갖고 있습니다.

시간복잡도는 어떻게 되나요?
큐와 스택 모두 탐색은 불가능 하고 삽입 삭제 O(1) 상수시간을 갖습니다.

#### Tree
Tree는 무엇인가요?
Tree는 Node로 구성되어 있는 계층형 자료구조로서 한 Node는 여러개의 자식 Node를 가질수 있는 자료구조 입니다.

### 객체지향 프로그래밍에 대해 설명해주세요.
객체지향 프로그래밍은 상태와 행위를 가진 객체들간에 상호작용을 통해 프로그래밍 하는 프로그래밍 패러다임 중 하나 입니다.


### 객체에 대해서 좀 더 자세히 말씀해주세요
객체는 클래스에서 정의된 것을 토대로 메모리에 할당 된 것으로 프로그램에서 사용하는 변수와 메소드들을 가지고 있는 구별된 메모리 공간입니다. 이 공간은 변수에 할당된 주소를 통해 접근 할 수 있습니다 즉 변수에 객체를 할당 할 수 있고 그 변수를 통해 객체가 가지고 있는 상태와 메소드를 접근 할 수 있습니다.


### 클래스를 언급하셨는데 클래스는 무엇인가요?
클래스는 상태와 메소드들의 이름과 타입을 결정해논 객체를 만들기 위한 설계도 입니다. 이 클래스를 만드는 것이 객체지향에서 추상화하는것이라 할 수 있습니다. 추상화란 공통의 속성이나 기능을 묶어 이름을 붙이는 것인데 이것이 딱 클래스를 정의 하는 것입니다.


### 캡슐화는 무엇인가요?
캡슐화도 클래스와 관련이 많습니다. 캡슐화의 뜻은 객체와 속성을 하나로 묶고 실제 구현 내용 일부를 감추어 외부에 은닉한다라는 뜻이 있습니다. 캡슐화는 한마디로 하나로 묶는다는 의미 입니다. 그래서 클래스를 정의하는것도 캡슐화 한다고 할 수 있습니다. 관련된 상태와 기능을 클래스로서 하나로 묶기 때문입니다. 그리고 이렇게 묶인 상태와 기능은 외부에서는 신경쓰지 않고 사용하기 때문에 감춰져 있습니다. 즉 클래스를 정의 한다는 것은 추상화와 캡슐화를 하는 것을 의미합니다.


### 상속과 다형성에 대해서도 설명해주세요
상속이란 두개의 클래스간에 관계로 하나의 클래스가 다른 하나의 클래스의 상태와 정의를 물려 받는 것을 말합니다. 그대로 가져오는것에서 나아가서 필요한 것은 추가하고 수정하며 새로운 클래스를 만드는 것입니다. 다형성은 다양한 형태를 가지고 있다는 의미로 상속이 존재하기 때문에 생긴 특징인데요 상속을 통해 부모 클래스의 메소드를 수정한 경우 같은 이름의 메소드 이지만 다른 기능을 할 수 있습니다. 이를 메소드 오버라이딩이라합니다. 또한 하나의 클래스 안에서도 파라미터를 다르게하여 같은 이름이지만 다양한 기능을 할 수 있게 하는 메소드 오버로딩도 있습니다.


### 객체지향에는 몇가지 설계원칙이 있는데요 이것을 설명해주세요
객체지향에는 5가지 설계원칙이 있습니다 앞글자만 따 SOLID라고 부르는데 하나씩 설명해드리겠습니다. S는 단일책임원칙을 말합니다. 클래스는 단 하나의 책임을 가져야 한다는 원칙입니다. O는 개방폐쇠원칙으로 확장에는 열려있고 수정에는 닫혀 있어야 한다는 의미입니다. 즉 기존의 코드의 수정을 최소화하면서 확장 해야 한다는 의미입니다. L은 리스코프 치환 원칙으로 부모클래스가 사용되는곳에 자식클래스를 사용하더라도 프로그램이 잘 동작 해야한다는 원칙입니다. I는 인터페이스 분리 원칙입니다. 자신이 사용하지 않는 인터페이스와는 의존관계를 맺지 말라는 원칙입니다. 마지막으로 D는 의존역전원칙입니다. 고수준의 모듈은 저 수준의 모듈에 의존하면 안된다는 원칙입니다.

### 함수형 프로그래밍은 무엇인가요?
함수형 프로그래밍은 상태와 가변 데이터를 지양하고 순수 함수를 이용해여 프로그래밍하는 프로그래밍 패러다임중 하나입니다.


### 순수함수를 이용한다 하셨는데 이것은 무엇인가요?
순수함수는 수학적인 함수라고도 하는데요, 수학적인 함수와 프로그래밍에서 쓰이는 함수는 조금 다른 면이 있습니다. 수학적인 함수는 입력값에 따라서만 출력값이 정해집니다. 반면에 흔히 프로그래밍에서 쓰이는 함수는 입력값과 외부상태에 의해 출력값이 정해집니다. 따라서 순수함수는 입력값에 의해서만 출력값이 정해지는 함수입니다.


### 상태와 가변데이터를 지양한다고 하셨는데 이것은 무슨 의미인가요?
흔히 객체지향프로그래밍에서 사용하는 클래스안의 프로퍼티들이 상태가 될 수 있습니다. Student라는 class에서 name이라는 속성이 이 객체의 상태라고 할 수 있습니다. 이러한 상태들이 함수 밖에 외부 상태들인데 이것이 순수함수를 막는 요인이 됩니다. 그래서 이러한 상태를 지양하는 것입니다.


### 함수형 프로그래밍에 특징을 조금 더 자세히 말씀 해주시겠어요?
함수형 프로그래밍에서는 함수를 독립적인 유닛으로 바라보기 때문에 1급 객체입니다. 즉 변수에 저장할 수 있고 함수의 입력값이나 출력값으로 반환 될 수 있습니다. 함수가 입력값에만 영향을 받기 때문에 병렬 처리에 더 효과적입니다. 왜냐하면 병렬처리에서 가장 큰 문제가 되는 부분이 공유자원에 접근 하는 부분입니다. 하지만 함수형 프로그래밍은 애초에 상태를 갖지 않기 때문에 공유자원의 접근의 위험성 자체가 사라집니다.


### 함수형 프로그래밍의 단점도 있나요 ?
단점은 상태를 갖고 있지 않기 때문에 어떠한 액션을 수행할때 마다 상태(객체)를 생성해야합니다. 그래서 굉장히 많은 메모리를 요구합니다.